# 数据结构与算法（C语言实现）
* 数据结构与算法与编程语言无关
    * 学习任何一门编程语言，都要学习数据结构与算法
    * 数据结构与算法可以用任何一门编程语言来实现
* 对程序员基本要求
* 尼古拉斯•沃斯（Pascal之父）：程序 = 数据结构 + 算法
    * 数据结构：研究的是数据之间的关系
        * 逻辑关系
            * 数据元素之间的逻辑关系（逻辑是指数学关系，先后等）
        * 物理关系
            * 数据元素之间的存储关系
    * 算法：解决问题的思路

## 绪论
* 数据结构
    * 从逻辑关系（元素之间的关系）上分为
        * 集合
            * 数据元素在同一个集合中，除此之外没有任何关系
            * 单个单个定义的变量：int a,b,c; int m,n; int x,y,z;
        * 线形结构
            * 一对一的关系
                * 除了第一个元素（首元素）以外，其余所有元素有且只有一个前驱
                * 除了最后一个元素（巍元素）以外，其余所有元素有且只有一个后继
                * 前驱：前面一个直接相邻
                * 后继：后面一个直接相邻
                * 数组：下标为i的元素，前驱arr[i-1]，后继arr[i+1]
                * 字符串
        * 树形结构
            * 描述的一对多的关系
                * 除了根节点以外，其余所有的节点有且只有一个父节点
                * 一个节点允许有任意多个子节点
        * 图形结构
            * 描述的是多对多的关系
                * 节点与节点之间是多对多的关系
            * 高铁网、人际关系网
    * 从物理关系（存储）分为
        * 顺序存储
            * 内存连续
            * 逻辑上相邻的元素在物理内存上也是相邻的
                * 用物理关系来记录逻辑上的关系
                * 线性：前驱和后继
                * 树：父与子
        * 链式存储
            * 用链（指针）来记录元素的逻辑关系
            * 用指针来指向前驱、后继、父节点、子节点
        * 索引存储
            * 除了存储数据元素本身以外，额外建立的索引表
                * 新华字典
            * 索引表独立于数据之外
            * 意义：
                * 方便查询数据
        * 哈希（散列）存储
            * 哈希函数
                * 直接建立数据元素和其存储位置的关系映射
            * 方便查找
                * 直接通过哈希函数计算出元素的存储位置
* 数据结构三要素
    * 逻辑结构
    * 物理结构
    * 数据运算：插入、删除、查找、遍历等
* 算法
    * 概念
        * 对特定问题求解步骤的描述，它是指令的有限序列
        * 算法是有穷的，程序执行可以是无穷的
    * 算法的五个重要特性
        * 有穷性
        * 确定性
        * 可行性
        * 输入：一个算法有0个或多个输入
        * 输出：一个算法至少有一个输出
    * 优秀算法的标准
        * 正确性
        * 可读性
        * 健壮性
            * 对于错误的输入也能够进行正常处理
        * 高效率与低存储
            * 程序执行效率高
            * 消耗内存少
    * 算法效率的度量（衡量算法优劣的标准），事先评估
        * 时间复杂度：时间角度
            * 并不是指代码的执行时间
            * 大致描述算法所需时间和问题规模的增长关系
            * 平局时间复杂度
            * 最好时间复杂度：按村换次数最少得算
            * 最坏时间复杂度：按循环次数最多的算
        * 空间复杂度：内存角度
            * 并不是指所需内存的大小
            * 大致描述算法所需内存和问题规模增长的关系
    * 直接使用程序运行的时间来记录算法的效率好不好？
        * 代码的质量会影响程序的运行时间
        * 不同机器执行相同的程序时间也不同
        * 外界干扰因素太多，不能准确衡量算法的效率

## 线性结构
* 顺序表
    * 除了首元素，其余元素有且只有一个前驱
    * 除了尾元素，其余元素有且只有一个后继
* 线性结构在存储上可以是顺序存储和链式存储

### 顺序表
* 顺序存储线性结构中的元素
* 元素按照其先后顺序依次存储在连续的内存空间中
* 用物理上相邻的关系来表示逻辑上的前驱与后继的关系
* 原生的顺序表，其实就是数组
    * 数组就是顺序表
* 静态顺序表
    * 表的大小不会发生改变，固定大小
    * 数组
* 动态顺序表
    * 表的大小会随着元素增加发生改变
    * 动态内存

### 链表
* 单向链表
* 双向链表
* 循环链表
* Linux内核的双向链表
* 栈
* 队列
* 优先队列

## 树形结构
* 树的理论
* 二叉排序（搜索）树
    * 先序
    * 中序
    * 后序
    * 层序
* AVL（平衡二叉排序/搜索）树
* 红黑树
* 霍夫曼树
* 堆

## 图论

* 图的存储
    * 领接矩阵
    * 领接表
    * 十字链表法
    * 多重链表发
* 图的遍历
    * DFS
    * BFS
* 最小生成树
    * prim，普里姆
    * kruskal，克鲁斯卡尔
* 拓扑序列
* 关键路径
* 最短路径
    * DFS
    * Floyd
    * dijsktra
    * bellman-ford
    * SPFA

## 算法

* 查找
* 排序
* 回溯
* 递归
* 贪心
* 动态对话
* KMP