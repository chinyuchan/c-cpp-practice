# CPP
C++代码的编译器是g++，但是也可以用gcc编译C++代码，要链接`stdc++`库。
```
g++ hello.cpp
gcc hello.cpp -lstdc++
```

## IO

| IO        | C        | C++    |
|-----------|----------|--------|
| stdin(0)  | scanf()  | cin对象  |
| stdout(1) | printf() | cout对象 |
| stderr(2) | perror() | cerr对象 |


## 名字空间
C++为了对全局变量、函数、宏、对象进行划分，避免名字冲突，将标准库的内容置于一个逻辑空间中，这个逻辑空间称为名字空间，即`std`。
* `using namespace std`
  * 使用名字空间`std`，即名字空间中的内容对当前作用于完全可见，当前作用中就可以直接使用名字空间中的所有函数、对象等。
* `use std`

## 枚举
* C++的枚举是强类型
* 枚举类型不能再用整数进行初始化或赋值
  * C中枚举是整数，可以用整数相互赋值和初始化
  * C++中整数不能赋值给枚举变量，但枚举值可以赋值给整数
* 枚举类型名可以省略`enum`关键字

## 联合
* C++支持匿名联合，允许C++中的变量以联合的方式存储布局

## 结构体
* 定义变量时，C++的`struct`关键字可以省略
* C++中，空结构体大小为`1`，C语言中空结构体大小为`0`
* C++中，结构体成员变量可以用static修饰，C语言中则不能
* C++中，结构体中可以定义函数，C语言中则不能
* C++中，结构体中支持继承，C语言中则不能

## 字符串
* C++中提供了字符串类型
* C语言中字符串：字面值字符串、字符数组，没有单独的字符串类型
* 字符串构造
  * 空构造
  * 字面值字符串构造
  * 构造函数构造
  * 用另外一个string构造
* 字符串操作
  * 可以用字符串直接赋值
  * 使用`+`操作符，拼接字符串
  * 支持`[]`操算符
  * 成员函数

## C++函数
* 支持重载、缺省值、哑元
* C++形参列表为空，表示void，在调用函数时不能穿任何参数
* C++不支持隐式声明，调用函数之前，必须先声明/定义
  * C语言支持隐式声明

### 函数重载
同一作用域中，函数名相同，参数列表不同。
* 在调用同名函数时，编译器会根据调用参数时传递的实参类型和个数来绑定调用的函数。在编译阶段就确定了调用的是哪个函数。
* 参数列表不同
  * 参数类型不同（同位置的形参类型）
  * 参数个数不同
  * 对于指针和引用类型的参数，常属性不同也构成重载
* 重载与函数返回值类型无关
* 调用重载函数
  * 调用重载函数，不是由程序员指定的，而是由编译器绑定的。
  * 编译器根据参数的个数和类型来绑定对应的函数，称为静态绑定。
  * 可能会引发歧义。
    * 在调用函数时，先根据函数名搜索函数。
    * 如果函数没有重载，如果类型不匹配，则编译器会对实参进行类型转换，如果能够转为参数的类型，则编译器直接绑定。如果不能转换，则编译器报错。
    * 如果调用的函数有重载，会根据参数的个数和类型进行匹配。如果有完全匹配的函数，则直接绑定。如果不能完全匹配，则对实参进行类型转换，转换后如果有合适的，也能进行绑定。
    * 如果没有完全匹配，类型转换后，有多个同等级的重载函数，则产生歧义。
      * 多个参数时，一个参数的类型转换高于多个参数的类型转换

### 重载原理
* g++编译器会对函数换名，汇编中的标示符与原函数名不同。
* gcc编译器不会对函数换名，汇编中的标示符与原函数名相同。

### extern "C"
* 告诉g++编译器，不要对函数进行更名操作
* C++开发的库给C语言用的时候，需要使用`extern "C"`

### 函数缺省值
* C++的形参可以有缺省值，调用时，可传参，也可不传
* 靠右原则：如果一个形参有缺省值，则其右边所有形参都必须由缺省值。
* 函数声明于定义分离时，缺省值只能出现在函数声明中。
* 注意缺省值和重载引发的歧义

### 哑元
* 形参只有类型名，没有形参名
  * C语言函数声明省略的形参名不算
* 只关心传递参数的类型，不关心值
* 意义在于构成重载，区分前++/--还是后++/--

### 内联函数
* C语言中内联函数为`static inline`
* C++中内联函数为`inline`
* 在调用内联函数时，并不是生成调用指令，而是直接使用内联函数的二进制指令替换调用指令，提高运行效率。
* 简单且使用频率高的函数定义为内联函数，才能突显内联的意义。

### 引用
* 引用即别名
* 定义引用形参，即用形参来引用实参，操作形参本质上就是操作实参
* 引用底层的本质是指针，把指针的解引用、取地址等复杂操作省略了
* 引用必须初始化
* 引用终身制
  * 引用了一个目标后，无法让这个引用再引用其他目标
  * 使用引用变量和目标变量是一样的，没有区别
* 对引用变量赋值，其实就是对目标变量赋值
* 引用不能为空
  * 没有空引用
* 引用一般用在形参列表
  * 不再使用指针传递参数，直接使用引用可以取代指针
  * 引用形参，可以修改实参的值
* 引用与指针的区别
  * 指针是实体变量，引用不是实体变量
    * sizeof(指针)==4/8
    * sizeof(引用)==目标大小
  * 指针可以为空，引用不能为空
  * 指针可以不初始化，引用必须初始化
  * 指针可以改变指向，引用不能修改引用目标
  * 可以定义指针的指针即二级指针，不可以定义引用的引用，没有二级引用
    * `int&&`是右值引用，不是二级引用
  * 可以定义指针的引用，不可以定义引用的指针
  * 可以定义数组的引用，不可以定义引用的数组
* const
  * C：变量只读，使用指针也能修改
  * C++：变量就是常量
    * const修饰的变量，使用常量进行初始化，编译时对所有使用该常量的地方直接使用常量值替换（编译期就能得到值）
    * const修饰的变量，使用变量进行初始化，运行时才能得到值。
  * C++中对象、指针、引用的常属性不能丢失，一旦丢失，编译报错。
  * C++中const修饰的变量必须初始化
* constexpr
  * C++11中引入，表示常量表达式
  * const修饰变量有两种情况
    * 初始值为常量表达式，编译阶段就被替换
      * 针对这种情况C++11引入了`constexpr`关键字来替换`const`
    * 初始值为非常量表达式
* 常对象与常对象引用
  * 常对象：常量
  * 用const修饰的对象，称为常对象
    * const修饰的是引用目标
  * 非常引用只能引用非常对象，常引用可以引用常对象和非常对象
* 左值引用与右值引用
  * 左值：可以置于`=`左边的值
  * 右值：不能置于`=`左边的值
  * 一般变量称为左值
  * 常量、字面值、表达式，称为右值
  * 左值引用`int& r= obj;`
    * 非常左值引用只能引用左值
    * 常左值引用可以引用右值
  * 右值引用`int&& r = obj;`
    * 只能引用右值
  * `const`和`constexpr`修饰的变量，依然是左值
* 引用的作用
  * 传参
    * 提高传参的效率、节省内存
  * 返回对象引用
    * 要保证函数返回后，所引用的对象依然有效

## 动态内存
* 可以使用C语言的`malloc/calloc/realloc/free`这套函数，但不建议
* C++申请动态内存使用`new`操作符
* C++申请数组动态内存空间使用`new[]`操作符
* 用`new`申请用`delete`释放，用`new[]`申请用`delete[]`释放，要对应起来
* C++中没有对应的`realloc`

### new/delete和malloc/free的区别
* `new/delete`是操作符，`malloc/free`是函数。
* `new`会调用类的构造函数，`delete`会调用类的析构函数，`malloc/free`则不会。
* `new`可以给申请的动态内存初始化，`malloc`则不能（`calloc`会清零）。
* `new`申请内存时只需指定类型，不需指定大小。`malloc`不需指定类型，而需指定大小。即`new`关心类型，`malloc`关心大小。
* `new`申请内存后，得到的指针类型为对应类型的指针，而`malloc`申请后得到的指针类型为`void*`，需要类型转换。
* `new`申请失败会抛出`bad_alloc`异常，`malloc`申请失败会返回`NULL`，并设置`errno`。

## 类型转换
* 隐式类型转换
  * 基础数据类型char、short、int、long、、float、double之间可以进行隐式类型转换
  * 隐式类型转换也称为自动类型转换
* 强制类型转换
  * 如果不用强制类型转换，编译报错
  * `(目标类型)(源对象)`
* 四种显式类型转换
  * 替代强制类型转换
    * 凡是需要用到强制类型转换的地方都是程序设计不合理
  * `static_cast<目标类型>(源对象)`
    * 静态类型转换
    * 只要源对象类型和目标类型之间，任意一方可以进行隐式类型转换，那么两个方向上都可以进行静态类型转换
      * 源对象类型->目标类型
      * 目标类型->源对象类型
  * `const_cast<目标类型>(源对象)`
    * 去常类型转换
    * 只适用于带有常属性的指针和引用，即源对象必须是常指针或常引用
    * 去除引用或指针的常属性
  * `dynamic_cast<目标类型>(源对象)`
    * 动态类型转换
    * 只能适用于存在多态父子关系的指针或引用之间
    * 子类的指针(或引用)可以隐式转换为父类的指针(或引用)，那么另一个方向可以用`static_cast`和`dynamic_cast`但有区别
      * `dynamic_cast`会检查目标的真实类型，可能转换失败，得到NULL
      * `static_cast`不会检查目标的真实类型，一定能转换成功（但有风险）
  * `reinterpret_cast<目标类型>(源对象)`
    * 重解释类型转换
    * 适用于不同类型指针之间的转换，以及指针与整数之间的转换
    * 父子之类指针之间
      * `static_cast`会计算指针偏移
      * `reinterpret_cast`不会计算指针偏移，得到的是错误地址

## string
* C++中尽量少用C风格字符串
* 连续内存空间

## vector
* 向量、顺序表
* 连续内存空间
* 泛型，存储任意类型

# 面向对象编程
## 面向过程
* C语言就是面向过程的编程语言
* 解决问题可以分解为若干步骤，每个步骤封装成对应的函数，解决问题就是依次调用各个函数。

## 面向对象编程
* C++、Java、Python都是面向对象编程
* 函数的意义?
  * 减少重复代码，提高复用率，提高开发效率
* 面向对象的意义
  * 减少重复代码，提高复用率，提高开发效率
  * 封装代码，对外保护代码实现
* 什么是面向对象
  * 一切皆对象，解决问题就是对象之间的相互联系与作用

## 类和对象
* 类：一类事物的抽象描述
* 对象：具体存在的事物，类具体的实例

## 类的封装
* C++中类可以使用`struct`或`class`定义。
* C++的类比C语言的struct多了成员函数和访问控制属性。
* C++中类可以定义成员函数
  * 成员函数中可以直接访问类的成员变量
  * 谁调用成员函数，就访问谁的成员变量

## 构造函数
* 创建对象时对成员变量初始化
* 面向对象初始化方式
  * 通过构造函数初始化
* 构造函数
  * 和类同名
  * 没有返回值
  * 可以有多个构造函数（重载），即实例化对象有多重方式
  * 不能显式调用，创建对象时，自动调用

## 访问控制属性
| 访问控制属性    | 本类中 | 子类中 | 其他  | friend |
|-----------|-----|-----|-----|--------|
| private   | 可以  | 不可以 | 不可以 | 可以     |
| protected | 可以  | 可以  | 不可以 | 可以     |
| public    | 可以  | 可以  | 可以  | 可以     |

* `private`：私有的，只有本类中才可以访问
* `protected`：受保护的，本类或子类中可以访问
* `public`：公开的，在任意地方都可以访问

## 友元
* 破坏访问控制属性的限制
* 在类中可以声明友元函数或友元类。

## 单参构造函数
* 参数可以隐式调用单参构造函数，构造出类对象
* 可以使用`explicit`关键字禁止这种隐式调用

## this
* 类的每个构造函数和成员函数中，都有一个隐含的`this`指针
* 构造函数的`this`指针，指向正在构造的对象
* 成员函数的`this`指针，指向正在调用该函数的对象
* 局部变量和成员变量同名时，可通过`this`指针区分

## 初始化列表
* 只有构造函数才有初始化列表
* 必须使用初始化列表的情况
  * `const`成员
  * 引用行成员
  * 没有无参构造的成员
* 初始化列表的执行顺序与初始化列表无关，只与成员定义的顺序有关
  * 先定义的成员变量先初始化

## 常对象与常方法
* 成员函数有无`const`会构成重载
* 常对象只能调用常函数，普通对象优先调用普通成员函数，当没有普通成员函数时，就调用常函数
* 常方法中`const`修饰的是`*this`，即调用该方法的对象
  * 指针与引用，有无常属性构成重载
* 常方法中不能对成员进行修改
  * `mutable`修饰的属性即使在常对象或常方法中也能被修改
* const修饰的对象，所有的属性都必须初始化

## 静态属性
* C++中`struct`和`class`的成员属性和方法都可以用`static`修饰
* 静态属性类内声明，类外定义
* 静态属性本上是加了`类名::`限制的全局变量
* 静态属性存储在全局作用域
  * `bss`：未初始化的全局变量
  * `data`：已初始化的全局变量
* `sizeof()`计算大小不包含静态属性
* 静态属性属于类而不属于对象

## 静态方法
* 可以使用`对象.`或`类名::`调用
* 静态方法不能访问非静态成员，也不能调用非静态方法，只能访问静态成员和静态方法，因为静态方法中没有隐含的this指针
* 静态属性本上是加了`类名::`限制的全局函数

## 构造函数
* 初始化成员
* 打开文件流
* 分配动态内存
* 构造函数的执行顺序
  * 按照继承的顺序，依次调用各个父类的无参构造函数
  * 按照类成员的定义顺序，依次调用各个类的无参构造函数
  * 最后执行当前类的构造函数

## 析构函数
* 关闭文件流
* 释放动态内存
* 当类中没有析构函数时，编译器会提供一个缺省的析构函数
* 没有参数和返回值，也就不能重载
* 对象消亡时自动调用
* 析构函数的执行顺序
  * 执行本类的析构函数
  * 按照类类型成员的定义顺序，逆序调用各个类的析构函数
  * 按照继承顺序，逆序调用各个父类的析构函数

## 名字空间
* 对代码进行逻辑划分
  * 减少代码冲突（类型冲定义、函数冲定义）
  * 一个名字空间相当于一个作用域
* 同名名字空间会自动合并
  * 一个名字空间会分属于不同的文件
* 匿名名字空间
  * 定义在全局作用域中的变量、函数、类，都会被放到匿名名字空间中，使用`::`访问
* 嵌套

## 域限定符
* 没有指定作用域，就到当前作用域查找，没找到就取全局作用域查找

## 拷贝构造函数
* 用一个已经存在的对象构造一个新的对象时，会调用一个拷贝构造函数
* 当没有提供拷贝构造函数时，编译器会提供一个缺省的拷贝构造函数，缺省的拷贝构造函数是浅拷贝
* 当需要深拷贝时，需要自己提供拷贝构造函数
* 可以重载，但一般只提供常版本
* 调用时机
  * 用一个已经存在的对象构造一个新的对象时
  * 函数非引用类类型传参
  * 向容器中存储对象

## 深拷贝浅拷贝
* 浅拷贝
  * 按字节复制
  * 对于指针成员，拷贝的是指针的值，会出现两个对象的指针成员指向同一块内存
* 深拷贝
  * 基础数据没有深拷贝这个概念
  * 对于指针成员，拷贝指针指向的内存中的数据
  * 实现步骤
    * 拷贝基础成员
    * 为指针分配内存
    * 拷贝指针所指向内存中的数据
  * STL中所有容器都支持深拷贝

## 拷贝赋值函数
* 两个已存在的对象赋值时，会调用拷贝赋值函数
* 如果类没有提供，编译器会提供一个缺省的拷贝赋值函数，其实现是浅拷贝
  ```c++
  类名& operator=(const 类名& other) {
      if (this != &other) { // 防止自赋值
          // ...
      }
      return *this; // 为了支持链式操作
  }
  ```
## 三五原则
* 析构函数、拷贝构造函数、拷贝赋值函数，一般一起实现
* 析构函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数，一般一起实现
## 移动构造函数
* 拷贝构造函数：用一个已经存在的对象构造一个新的对象
  * 如果旧的对象不再需要使用了，就可以使用移动构造函数
* 移动
  * 把已存在的对象资源转移给新的对象
  * 只有动态内存资源才需转移
## 移动赋值函数
* 用一个对象对另一个对象赋值
  * 如果赋值的对象不再使用，可以使用移动赋值函数
  * 一般在函数返回对象时会调用
## 操作符重载
* 对于自定义类型，操作符不一定能够直接作用于自定义的类型对象
* 为了让自定义类型能够使用基础操作符，则需要重载操作符
* 分类
  * 单目：只有一个操作数 `!` `~` `++` `--` `+` `-`
  * 双目：有两个操作数`+` `-` `*` `/` `%`
  * 三目：只有`?:`
* 重载方式
  * 成员方式
  * 全局方式
* 只能以成员方式
  * `=`：赋值操作符
  * `()`：函数操作符
  * `[]`：下标操作符
  * `->`：间接成员访问操作符
* 只能以全局方式
  * 输入输出操作符：`<<` `>>`
* 不能重载
  * `? :`：三目操作符
  * `.`：成员访问操作符
  * `.*`：成员指针解引用操作符
  * `::`：作用于限定符
  * `sizeof`
  * `typeid`
* 关系操作符
  * 在`find`查找算法中，需要重载`operator==`
  * 在`sort`排序算法中，需要重载`operator<`
  * 对象放入`set`/`multiset`/`map`/`multimap`中时，由于它们用的时红黑树，需要重载`operator<`
* 函数操作符
  * 一个类如果重载了`operator()`，则该类的对象称为函数对象或仿函数。
* 类型操作符
  * 有`A`类对象`a`和`B`类对象`b`，让`a`转成`b`的办法有哪些？
    * 在B类中添加A类型的单参构造函数
      ```c++
      class B {
      public:
          B(const A& a) {}
      };
      ```
    * 在A类中重载B类型操作符
      ```c++
      class A {
      public:
          operator B() {}
      };
      ```
  * A是类类型，B是基础类型
    * 只能在A类中提供B类型的单参构造`A(const B& b)`
  * A是基础类型，B是类类型
    * 只能在B类中提供`operator A()`函数
## 继承
* 父类/子类
* 基类/派生类
* C++支持多继承，一个子类可以继承多个父类
* 继承方式
  * `class`的缺省继承方式为`private`，`struct`的缺省继承方式为`public`
  
  | 私有继承  | private属性 | protected属性 | public属性 |
  |-------|-----------|-------------|----------|
  | 子类    | N         | Y           | Y        |
  | 子类的子类 | N         | N           | N        |
  | 类外    | N         | N           | N        |
  
  | 保护继承  | private属性 | protected属性 | public属性 |
  |-------|-----------|-------------|----------|
  | 子类    | N         | Y           | Y        |
  | 子类的子类 | N         | Y           | Y        |
  | 类外    | N         | N           | N        |
  
  | 公开继承  | private属性 | protected属性 | public属性 |
  |-------|-----------|-------------|----------|
  | 子类    | N         | Y           | Y        |
  | 子类的子类 | N         | Y           | Y        |
  | 类外    | N         | N           | Y        |

* 继承的意义
  * 扩展类的功能
  * 复用代码
* 子类对象可以“转换”为父类类型的对象
  * 可以用父类类型的引用，来引用子类对象
  * 可以用父类类型的指针，来指向子类对象
* 父类指针指向子类对象，实际指向的是子类对象中的父类部分
  * 指针会偏移
* 父类引用引用子类对象，实际引用的是子类对象中的父类部分
* 子类的构造函数（子类的无参构造函数默认调用父类的无参构造函数）
  * 先按照继承顺序，依次默认调用父类的无参构造函数
  * 再按照类成员的定义的顺序，依次调用各个类成员的无参构造函数
  * 最后执行构造函数中的代码
* 子类的析构函数
  * 先执行析构函数中的代码
  * 再按照类成员定义的顺序，逆序调用各个类的析构函数
  * 最后按照继承顺序，逆序调用各个父类的析构函数
* 子类的拷贝构造
  * 按照继承顺序，依次调用各个父类的拷贝构造函数
  * 按照类成员的声明顺序，依次调用各个类成员的拷贝构造函数
  * 自己实现的拷贝构造函数，一般需要在初始化列表中调用父类的拷贝构造函数和类成员的拷贝构造函数
* 子类的拷贝赋值函数
  * 先按照继承的顺序，依次调用各个父类的拷贝赋值函数
  * 再按照类成员的定义顺序，依次调用各个类成员的拷贝赋值函数
  * 最后执行自己的拷贝函数体
  * 若自己实现拷贝赋值函数，需要拷贝父类子对象，类成员
* 子类的移动构造和移动赋值也需保证能够调用父类的相关函数
* 子类和父类的同名标识符
  * 子类中会隐藏父类的同名标识符
  * 如果需要访问父类的同名属性或函数，需要加上`父类::`限定符
* 菱形继承
  * 如果一个类继承多个父类，它的父类们又有共同的祖先，这种继承称为菱形继承
  * 公共的祖先类沿着不同的继承路径，公共的属性会保留多份
  * 沿着不同的继承路径的方法，操作的属性也不是同一份
  * 在继承公共祖先时，可使用virtual继承，增加一个指针内存空间大小，最终的子类中，操作的是同一份属性
* 多态
  * 用父类类型的指针，指向子类对象
  * 用父类类型的引用，引用子类对象
  * 调用父类中被子类重写的虚函数，实际上调用的是子类重写的虚函数
* 虚函数
  * 不能声明为虚函数
    * 构造函数
    * 全局函数
    * 静态函数
    * 内联函数
  * 可以声明为虚函数
    * 普通成员函数
    * 析构函数
* 重写（`override`）的条件
  * 子类重写父类中同名的虚函数
    * 子类重写父类虚函数时，可以不加virtual
  * 子类重写的虚函数参数列表必须相同
    * 对于普通数据类型，有无const不影响
    * 如果是指针或引用类型，则常属性则必须一致，才能构成重写
 * 子类重写的虚函数，必须和父类拥有相同的常属性
* 重写对返回值的限制
  * 若父类虚函数返回基础类型或基础类型的指针（或引用），则子类重写的虚函数的返回值必须和父类虚函数一致
  * 若父类虚函数返回类类型的指针（或引用），则子类重写的虚函数的返回值允许和父类虚函数不同
    * 允许子类返回父类虚函数返回值的子类的指针或引用
* 子类重写的虚函数，不能声明更多的异常
* 子类重写的虚函数，访问控制属性不会影响多态
  * 父类虚函数是公有的，子类重写时改为私有的，多态时依然可以调用子类的私有函数
* 父类中的私有虚函数，子类也能重写
  * 只能在父类或父类的友元中，呈现多态的效果
* 重载/重写/隐藏
  * 重载：同一作用域，函数名相同，参数列表不同
  * 重写：子类重写父类的虚函数，函数名相同，参数列表相同，常属性相同
  * 隐藏：子类隐藏父类中同名的标识符
* `typeid`
  * 操作符
  * 获取变量的运行时信息
    * 多态时可以获取指针或引用实际目标的信息
  * 运行结果为`typeinfo`对象
    * 有`name()`成员函数，打印运行时信息字符串
    * 重载了`==`和`!=`操作符
* `dynamic_cast`
  * 适用场合：具有多态关系，父子类型的指针、引用
  * 会检查源类型与目标类型是否一致，若不一致，则转换失败
    * 若转换指针失败，得到`0`地址
    * 若转换引用失败，抛出`bad_cast`异常
  * 比`static_cast`更安全，因为多了类型检查
* 虚表和虚表指针
  * 空类大小为1字节
  * 非空类大小需要补齐
  * 类中如果有虚函数，该类的对象会增加一个指针成员，称为虚表指针
  * 虚表指针
    * 指向虚函数表的指针
    * 类所有对象的虚表指针都是相同的，即指向同一张虚表（数组）
  * 虚函数表
    * 编译器会为有虚函数的类创建一张虚函数表
    * 表中的每一项都是一个虚函数地址
* 动态绑定（重写/覆盖的本质）
  * 每个子类对象会从父类继承虚函数表，如果没有重写任何虚函数，那么子对象虚函数表内容和父类虚函数表内容相同。
  * 若重写了某个虚函数，则在子对象的虚函数表中，会用子对象重写的函数地址替换掉原来表中的父类虚函数地址。
  * 覆盖的本质
    * 覆盖从基类继承的虚函数表中的虚函数地址
* 静态绑定
  * 在编译阶段，确定调用函数，生成调用指令
* 动态绑定
  * 编译阶段，并不生成调用指定，而是用一段指令替换调用指令。
    * 根据指针（或引用）找到目标对象
    * 从对象中拿到虚表指针，从虚表中找到对应的虚函数并调用
  * 在运行时，确定调用的函数
* 纯虚函数与抽象类
  * 一个类有纯虚函数则该类为抽象类。
    * 抽象类不能实例化对象。
  * 一个类继承抽象类时，只有把所有的纯虚函数重写后，才不是抽象类。
* 抽象类的意义
  * 虽然不能实例化，但是可以用指针（或引用），指向（或引用）子类对象，实现多态
  * 相当于统一了接口
  * 提供了公共类型
* 纯抽象类
  * 除了编译器自动生成的函数外，都是纯虚函数的类。
* `override`
  * C++11关键字
  * 编译器会检查函数是否满足重写的条件，若不满足，编译报错
* `final`
  * C++11关键字
  * 修饰类，表示类不能被继承
  * 修饰虚函数，表示该函数不能被重写
* 异常机制
  * 异常：不正常的执行流程。
  * C语言都过返回值表示错误
    * 如果返回值包含了所有可能，就无法用一个特殊的值来表示错误。
    * 正常和错误的逻辑混在一起
    * `setjmp`/`setlongjmp`
      * 跳转时，之前所有的局部对象都无法被析构。
    ```
      #include <setjmp.h>
      int setjmp(jmp_buf env);
      void longjmp(jmp_buf env, int val);
    ```
  * C++出错采用异常机制
    * 抛出异常时，程序从抛出异常代码处直接中断返回。
    * 异常时一层一层往上抛的，抛到上一层调用的函数。
    * 可是用`try`/`catch`捕获异常，捕获异常后，则执行异常处理代码。如果没有捕获异常，则会一直往上抛，直至异常被捕获。
      如果一直都没有捕获，则会抛给操作系统，操作系统会执行异常的默认操作（中断整个程序）。
    * 抛出异常前，所有的局部变量都能析构。
      * 动态内存，还是无法释放，但可以用智能指针解决这个问题。
  * 标准库中的一些异常类型
    * `bad_alloc`
    * `bad_cast`
    * `out_of_range`
* 抛出异常
  * `throw`
    * 所有数据类型都可以作为异常类型，一般来说，异常都是特殊的类型
* 捕获异常
  * `try-catch`
    * 没有抛出异常时，`try-catch`不影响程序流程
  * 异常是根据类型来判断的，一种类型对应一种异常
    * 如果所有的异常类型都无法匹配，则会继续向外抛出
  * `catch`分支可以有很多
    * 从上往下，逐个匹配
    * 子类对象可以隐式转为父类对象
    * 当异常类型存在父子关系时，应先`catch`子类类型
* `exception`
  * 标准库中异常类型的基类
  * 自定义异常一般会继承exception类
  * `logic_error`
    * `out_of_range`
  * `runtime_error`
    * `overflow_error`
    * `underflow_error`
  * `bad_alloc`
  * `bad_typeid`
* 函数异常说明
  * 声明函数时，可以提供异常说明和`noexcept`说明符，以限制函数能够抛出的异常种类
    * 限制异常的种类说的是：如果抛出了异常说明以外的异常类型，即使写了`try-catch`，也无法捕获
    * 因此只能抛出异常说明中的异常类型
      * `throw()`就是不抛出任何异常

* 抛出异常
  * 如果在构造函数中抛出异常，则该对象时不完整的对象，不完整对象不会调用析构函数
    * 在catch中先释放之前申请的内存
  * 永远不要在析构函数中抛出异常
    * 因为析构函数将永远无法执行之后的步骤，可能造成资源无法释放

## I/O

|      | C++      | C          |
|------|----------|------------|
| 标准输入 | `cin`对象  | `scanf`函数  |
| 标准输出 | `cout`对象 | `printf`函数 |
| 标准错误 | `cerr`对象 | `perror`函数 |

### 基于流的I/O
* istream
  * 输入对象的基类











































